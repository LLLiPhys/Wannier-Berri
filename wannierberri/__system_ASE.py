#                                                            #
# This file is distributed as part of the WannierBerri code  #
# under the terms of the GNU General Public License. See the #
# file `LICENSE' in the root directory of the WannierBerri   #
# distribution, or http://www.gnu.org/copyleft/gpl.txt       #
#                                                            #
# The WannierBerri code is hosted on GitHub:                 #
# https://github.com/stepan-tsirkin/wannier-berri            #
#                     written by                             #
#           Stepan Tsirkin, University of Zurich             #
#   some parts of this file are originate                    #
# from the translation of Wannier90 code                     #
#------------------------------------------------------------#

import numpy as np
import copy
import functools
import multiprocessing 
from .__utility import iterate3dpm, real_recip_lattice,fourier_q_to_R
from .__system_w90 import ws_dist_map_gen, System_w90
from time import time

np.set_printoptions(precision=4,threshold=np.inf,linewidth=500)

class System_ASE(System_w90):
    """
    System initialized from the Wannier functions generated by `ASE <https://wiki.fysik.dtu.dk/ase/_modules/ase/dft/wannier.html>`__ .
    
    Parameters
    ----------
    ase_wannier : 
        An object of  `ASE Wannier <https://wiki.fysik.dtu.dk/ase/_modules/ase/dft/wannier.html#Wannier>`__ . 
    transl_inv : bool
        Use Eq.(31) of `Marzari&Vanderbilt PRB 56, 12847 (1997) <https://journals.aps.org/prb/abstract/10.1103/PhysRevB.56.12847>`_ for band-diagonal position matrix elements
    npar : int
        number of processes used in the constructor
    fft : str
        library used to perform the fast Fourier transform from **q** to **R**. ``fftw`` or ``numpy``. (practically does not affect performance, 
        anyway mostly time of the constructor is consumed by reading the input files)

    Notes
    -----
    see also  parameters of the :class:`~wannierberri.System` 
    """

    def __init__(self,ase_wannier,
                    transl_inv=True,
                    fft='fftw',
                    npar=multiprocessing.cpu_count()  , 
                    **parameters
                    ):

        self.set_parameters(**parameters)
        self.seedname="ASE"
        self.real_lattice,self.recip_lattice=real_recip_lattice(real_lattice = ase_wannier.unitcell_cc)
        self.mp_grid=ase_wannier.kptgrid
        self.iRvec,self.Ndegen=self.wigner_seitz(self.mp_grid)
        self.nRvec0=len(self.iRvec)
        self.num_wann=ase_wannier.nwannier
        self.wannier_centres_cart = ase_wannier.get_centers()
        self.wannier_centres_reduced = self.wannier_centres_cart.dot(np.linalg.inv(self.real_lattice))
        self.kpt_latt =  ase_wannier.kpt_kc

        if  self.use_ws:
            print ("using ws_distance")
            ws_map=ws_dist_map_gen(self.iRvec,self.wannier_centres_cart, self.mp_grid,self.real_lattice, npar=npar)
        
        if self.getAA or self.getBB:
            self.Z_dkww = wannier_ase.Z_dkww
            self.weight_d, self.Gdir_dc, self.Ndir = wannier_ase.weight_d, wannier_ase.Gdir_dc , wannier_ase.Ndir
            raise NotImplementedError()

        kpt_mp_grid=[tuple(k) for k in np.array( np.round(self.kpt_latt*np.array(self.mp_grid)[None,:]),dtype=int)%self.mp_grid]
        if (0,0,0) not in kpt_mp_grid:
            raise ValueError("the grid of k-points read from .chk file is not Gamma-centrered. Please, use Gamma-centered grids in the ab initio calculation")
#        print ("kpoints:",kpt_mp_grid)
        
        fourier_q_to_R_loc=functools.partial(fourier_q_to_R, mp_grid=self.mp_grid,kpt_mp_grid=kpt_mp_grid,iRvec=self.iRvec,ndegen=self.Ndegen,numthreads=npar,fft=fft)

        timeFFT=0
        t0=time()
        self.HH_R=np.array([ase_wannier.get_hopping(R) for R in self.iRvec]).transpose((1,2,0))
        timeFFT+=time()-t0

        if self.getAA:
            AAq=chk.get_AA_q(mmn,transl_inv=transl_inv)
            t0=time()
            self.AA_R=fourier_q_to_R_loc(AAq)
            timeFFT+=time()-t0

        if self.getBB:
            raise NotImplementedError()

        if self.getCC:
            raise NotImplementedError()

        if self.getSS:
            raise NotImplementedError()

        if self.getSA:
            raise NotImplementedError()

        if self.getSHA:
            raise NotImplementedError()

        print ("time for FFT_q_to_R : {} s".format(timeFFT))
        if  self.use_ws:
            for X in ['HH','AA','BB','CC','SS','FF','SA','SHA','SR','SH','SHR']:
                XR=X+'_R'
                if hasattr(self,XR) :
                    print ("using ws_dist for {}".format(XR))
                    vars(self)[XR]=ws_map(vars(self)[XR])
            self.iRvec=np.array(ws_map._iRvec_ordered,dtype=int)

        self.set_symmetry()
        self.check_periodic()

        print ("Number of wannier functions:",self.num_wann)
        print ("Number of R points:", self.nRvec)
        print ("Recommended size of FFT grid", self.NKFFT_recommended)
        print ("Real-space lattice:\n",self.real_lattice)



